{"ast":null,"code":"\"use strict\";\n\nvar handleRequest = require(\"./handle_request\");\nvar utils = require(\"./utils\");\nvar VERBS = [\"get\", \"post\", \"head\", \"delete\", \"patch\", \"put\", \"options\", \"list\", \"link\", \"unlink\"];\nfunction adapter() {\n  return function (config) {\n    var mockAdapter = this;\n    return new Promise(function (resolve, reject) {\n      handleRequest(mockAdapter, resolve, reject, config);\n    });\n  }.bind(this);\n}\nfunction getVerbObject() {\n  return VERBS.reduce(function (accumulator, verb) {\n    accumulator[verb] = [];\n    return accumulator;\n  }, {});\n}\nfunction reset() {\n  resetHandlers.call(this);\n  resetHistory.call(this);\n}\nfunction resetHandlers() {\n  this.handlers = getVerbObject();\n}\nfunction resetHistory() {\n  this.history = getVerbObject();\n}\nfunction MockAdapter(axiosInstance, options) {\n  reset.call(this);\n  if (axiosInstance) {\n    this.axiosInstance = axiosInstance;\n    // Clone the axios instance to remove interceptors\n    // this is used for the passThrough mode with axios > 1.2\n    this.axiosInstanceWithoutInterceptors = axiosInstance.create ? axiosInstance.create() : undefined;\n    this.originalAdapter = axiosInstance.defaults.adapter;\n    this.delayResponse = options && options.delayResponse > 0 ? options.delayResponse : null;\n    this.onNoMatch = options && options.onNoMatch || null;\n    axiosInstance.defaults.adapter = this.adapter.call(this);\n  } else {\n    throw new Error(\"Please provide an instance of axios to mock\");\n  }\n}\nMockAdapter.prototype.adapter = adapter;\nMockAdapter.prototype.restore = function restore() {\n  if (this.axiosInstance) {\n    this.axiosInstance.defaults.adapter = this.originalAdapter;\n    this.axiosInstance = undefined;\n  }\n};\nMockAdapter.prototype.reset = reset;\nMockAdapter.prototype.resetHandlers = resetHandlers;\nMockAdapter.prototype.resetHistory = resetHistory;\nvar methodsWithConfigsAsSecondArg = [\"any\", \"get\", \"delete\", \"head\", \"options\"];\nfunction convertDataAndConfigToConfig(method, data, config) {\n  if (methodsWithConfigsAsSecondArg.includes(method)) {\n    return validateconfig(method, data || {});\n  } else {\n    return validateconfig(method, Object.assign({}, config, {\n      data: data\n    }));\n  }\n}\nvar allowedConfigProperties = ['headers', 'params', 'data'];\nfunction validateconfig(method, config) {\n  for (var key in config) {\n    if (!allowedConfigProperties.includes(key)) {\n      throw new Error('Invalid config property ' + JSON.stringify(key) + ' provided to ' + toMethodName(method) + '. Config: ' + JSON.stringify(config));\n    }\n  }\n  return config;\n}\nfunction toMethodName(method) {\n  return \"on\" + method.charAt(0).toUpperCase() + method.slice(1);\n}\nVERBS.concat(\"any\").forEach(function (method) {\n  MockAdapter.prototype[toMethodName(method)] = function (matcher, data, config) {\n    var _this = this;\n    var matcher = matcher === undefined ? /.*/ : matcher;\n    var delay;\n    var paramsAndBody = convertDataAndConfigToConfig(method, data, config);\n    function reply(code, response, headers) {\n      var handler = [matcher, paramsAndBody, paramsAndBody.headers, code, response, headers, false, delay];\n      addHandler(method, _this.handlers, handler);\n      return _this;\n    }\n    function withDelayInMs(_delay) {\n      delay = _delay;\n      var respond = requestApi.reply.bind(requestApi);\n      Object.assign(respond, requestApi);\n      return respond;\n    }\n    function replyOnce(code, response, headers) {\n      var handler = [matcher, paramsAndBody, paramsAndBody.headers, code, response, headers, true, delay];\n      addHandler(method, _this.handlers, handler);\n      return _this;\n    }\n    var requestApi = {\n      reply: reply,\n      replyOnce: replyOnce,\n      withDelayInMs: withDelayInMs,\n      passThrough: function passThrough() {\n        var handler = [matcher, paramsAndBody];\n        addHandler(method, _this.handlers, handler);\n        return _this;\n      },\n      abortRequest: function () {\n        return reply(function (config) {\n          var error = utils.createAxiosError(\"Request aborted\", config, undefined, \"ECONNABORTED\");\n          return Promise.reject(error);\n        });\n      },\n      abortRequestOnce: function () {\n        return replyOnce(function (config) {\n          var error = utils.createAxiosError(\"Request aborted\", config, undefined, \"ECONNABORTED\");\n          return Promise.reject(error);\n        });\n      },\n      networkError: function () {\n        return reply(function (config) {\n          var error = utils.createAxiosError(\"Network Error\", config);\n          return Promise.reject(error);\n        });\n      },\n      networkErrorOnce: function () {\n        return replyOnce(function (config) {\n          var error = utils.createAxiosError(\"Network Error\", config);\n          return Promise.reject(error);\n        });\n      },\n      timeout: function () {\n        return reply(function (config) {\n          var error = utils.createAxiosError(config.timeoutErrorMessage || \"timeout of \" + config.timeout + \"ms exceeded\", config, undefined, config.transitional && config.transitional.clarifyTimeoutError ? \"ETIMEDOUT\" : \"ECONNABORTED\");\n          return Promise.reject(error);\n        });\n      },\n      timeoutOnce: function () {\n        return replyOnce(function (config) {\n          var error = utils.createAxiosError(config.timeoutErrorMessage || \"timeout of \" + config.timeout + \"ms exceeded\", config, undefined, config.transitional && config.transitional.clarifyTimeoutError ? \"ETIMEDOUT\" : \"ECONNABORTED\");\n          return Promise.reject(error);\n        });\n      }\n    };\n    return requestApi;\n  };\n});\nfunction findInHandlers(method, handlers, handler) {\n  var index = -1;\n  for (var i = 0; i < handlers[method].length; i += 1) {\n    var item = handlers[method][i];\n    var isReplyOnce = item[6] === true;\n    var comparePaths = item[0] instanceof RegExp && handler[0] instanceof RegExp ? String(item[0]) === String(handler[0]) : item[0] === handler[0];\n    var isSame = comparePaths && utils.isEqual(item[1], handler[1]) && utils.isEqual(item[2], handler[2]);\n    if (isSame && !isReplyOnce) {\n      index = i;\n    }\n  }\n  return index;\n}\nfunction addHandler(method, handlers, handler) {\n  if (method === \"any\") {\n    VERBS.forEach(function (verb) {\n      handlers[verb].push(handler);\n    });\n  } else {\n    var indexOfExistingHandler = findInHandlers(method, handlers, handler);\n    // handler[6] !== true indicates that a handler only runs once.\n    // It's supported to register muliple ones like that without\n    // overwriting the previous one.\n    if (indexOfExistingHandler > -1 && handler[6] !== true) {\n      handlers[method].splice(indexOfExistingHandler, 1, handler);\n    } else {\n      handlers[method].push(handler);\n    }\n  }\n}\nmodule.exports = MockAdapter;\nmodule.exports.default = MockAdapter;","map":null,"metadata":{},"sourceType":"script"}