{"ast":null,"code":"/**\r\n * Expose `pathToRegexp`.\r\n */\n\nmodule.exports = pathToRegexp;\n\n/**\r\n * Match matching groups in a regular expression.\r\n */\nvar MATCHING_GROUP_REGEXP = /\\\\.|\\((?:\\?<(.*?)>)?(?!\\?)/g;\n\n/**\r\n * Normalize the given path string,\r\n * returning a regular expression.\r\n *\r\n * An empty array should be passed,\r\n * which will contain the placeholder\r\n * key names. For example \"/user/:id\" will\r\n * then contain [\"id\"].\r\n *\r\n * @param  {String|RegExp|Array} path\r\n * @param  {Array} keys\r\n * @param  {Object} options\r\n * @return {RegExp}\r\n * @api private\r\n */\n\nfunction pathToRegexp(path, keys, options) {\n  options = options || {};\n  keys = keys || [];\n  var strict = options.strict;\n  var end = options.end !== false;\n  var flags = options.sensitive ? '' : 'i';\n  var lookahead = options.lookahead !== false;\n  var extraOffset = 0;\n  var keysOffset = keys.length;\n  var i = 0;\n  var name = 0;\n  var pos = 0;\n  var backtrack = '';\n  var m;\n  if (path instanceof RegExp) {\n    while (m = MATCHING_GROUP_REGEXP.exec(path.source)) {\n      if (m[0][0] === '\\\\') continue;\n      keys.push({\n        name: m[1] || name++,\n        optional: false,\n        offset: m.index\n      });\n    }\n    return path;\n  }\n  if (Array.isArray(path)) {\n    // Map array parts into regexps and return their source. We also pass\n    // the same keys and options instance into every generation to get\n    // consistent matching groups before we join the sources together.\n    path = path.map(function (value) {\n      return pathToRegexp(value, keys, options).source;\n    });\n    return new RegExp(path.join('|'), flags);\n  }\n  path = path.replace(/\\\\.|(\\/)?(\\.)?:(\\w+)(\\(.*?\\))?(\\*)?(\\?)?|[.*]|\\/\\(/g, function (match, slash, format, key, capture, star, optional, offset) {\n    pos = offset + match.length;\n    if (match[0] === '\\\\') {\n      backtrack += match;\n      return match;\n    }\n    if (match === '.') {\n      backtrack += '\\\\.';\n      extraOffset += 1;\n      return '\\\\.';\n    }\n    backtrack = slash || format ? '' : path.slice(pos, offset);\n    if (match === '*') {\n      extraOffset += 3;\n      return '(.*)';\n    }\n    if (match === '/(') {\n      backtrack += '/';\n      extraOffset += 2;\n      return '/(?:';\n    }\n    slash = slash || '';\n    format = format ? '\\\\.' : '';\n    optional = optional || '';\n    capture = capture ? capture.replace(/\\\\.|\\*/, function (m) {\n      return m === '*' ? '(.*)' : m;\n    }) : backtrack ? '((?:(?!/|' + backtrack + ').)+?)' : '([^/' + format + ']+?)';\n    keys.push({\n      name: key,\n      optional: !!optional,\n      offset: offset + extraOffset\n    });\n    var result = '(?:' + format + slash + capture + (star ? '((?:[/' + format + '].+?)?)' : '') + ')' + optional;\n    extraOffset += result.length - match.length;\n    return result;\n  });\n\n  // This is a workaround for handling unnamed matching groups.\n  while (m = MATCHING_GROUP_REGEXP.exec(path)) {\n    if (m[0][0] === '\\\\') continue;\n    if (keysOffset + i === keys.length || keys[keysOffset + i].offset > m.index) {\n      keys.splice(keysOffset + i, 0, {\n        name: name++,\n        // Unnamed matching groups must be consistently linear.\n        optional: false,\n        offset: m.index\n      });\n    }\n    i++;\n  }\n  path += strict ? '' : path[path.length - 1] === '/' ? '?' : '/?';\n\n  // If the path is non-ending, match until the end or a slash.\n  if (end) {\n    path += '$';\n  } else if (path[path.length - 1] !== '/') {\n    path += lookahead ? '(?=/|$)' : '(?:/|$)';\n  }\n  return new RegExp('^' + path, flags);\n}\n;","map":null,"metadata":{},"sourceType":"script"}